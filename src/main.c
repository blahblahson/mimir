#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>
#include <mpi.h>
#include <signal.h>
#include "util.h"
#include "set.h"
#include "list.h"
#include "formula.h"
#include "rule.h"
#include "logic.h"
#include "modes.h"
#include "parallel.h"

/*
(2658,1624)
(2658,1720)
(2658,1784)
(2658,1800)
(2659,595)
(2659,647)
*** glibc detected *** /home/alvin/projects/mimir/mim: realloc(): invalid next size: 0x08930600 ***
^C
Program received signal SIGINT, Interrupt.
0xb7fdd424 in __kernel_vsyscall ()
(gdb) bt
#0  0xb7fdd424 in __kernel_vsyscall ()
#1  0xb7d81741 in ?? () from /lib/i386-linux-gnu/libc.so.6
#2  0xb7d0295e in ?? () from /lib/i386-linux-gnu/libc.so.6
Backtrace stopped: previous frame identical to this frame (corrupt stack?)
*/ 


/* signal business... when running in mode B any sister process could find a
 * new inference, in which case it calls MPI_Abort which will send a signal
 * SIGINT to all other siblings before exiting. here we catch this and set the
 * global variable below which will be caught by the mode B main loop,
 * signifying that we should blow this joint. a checkpoint will be set and then
 * a clean exit done (return 0) */
int letsblowthisjoint;

// TODO: consider a more general handler for similar signals to SIGINT
void SIGINT_handler(int signum)
{
    letsblowthisjoint = 1;
}

/* generate ALL balanced formulae of n variables */
int **genbfold(int n)
{
    int s[n], m[n]; s[0] = -1;
    int i, j, k, l; /* we do a lot of counting... */
    int **ret = NULL;
    int n_ret = 0;
    int partsize;
    int part[2*n], delim[2*n];

    while((partsize = partition(n, s, m))) {
        /* part = A1,.,A2,.,A3,.,A4,.,...,Apartsize,.
         * Ak = atoms in subset k */
        memset(delim, 0, 2*n*sizeof(int));

        for(i = 0, k = 0; i < partsize; i++) {
            for(j = 0; j < n; j++) {
                if(s[j] == i+1) {
                    part[k++] = j; /* important here: this means we generally
                                        don't use 0 as a variable, even though
                                        it is a valid one */
                }
            }
            part[k++] = OP_FIN;
            delim[i+1] = k;
        }

        /* for every partition, add an AND/OR and a ), plus the n variables,
         * and then the final . */
        int n_formula = partsize*2+n+1;

        /* now we collect all permutations of (1,...,partsize) */
        int **perm = NULL;
        int *pv = NULL;
        permute(partsize, 0, &perm, &pv);
        free(pv); /* TODO: THIS PERMUTATION FUNCTION SUCKS, I HATE IT */

        int n_perms = length_l((void **)perm); /* this will be n! */
        for(i = 0; i < n_perms; i++) {
            /* since we end up with ...,ANDOR(A1),... where A1 is the
             * perm[i][0]th partition, if said partition contains only one atom
             * then we discount it because it is a redundant form of another
             * formula generated by a different partition earlier or later on
             */
            if(length(part+delim[perm[i][0]]) < 2) continue;

            enum OPERATOR op = OP_OR;

            /* make the OR,AND,OR,... */
            int *formula1 = malloc(n_formula*sizeof(int));
            int *formula2 = malloc(n_formula*sizeof(int));

            for(l = 0; l < partsize; l++) {
                formula1[l] = op;
                op = (op == OP_AND) ? OP_OR : OP_AND; /* alternate! */
                formula2[l] = op;
            }

            for(j = 0; j < partsize; j++) {
                /* push part[delim[perm[i][j]]+k] up to OP_FIN */
                for(k = 0; part[delim[perm[i][j]]+k] != OP_FIN; k++, l++)
                    formula1[l] = formula2[l] = part[delim[perm[i][j]]+k];
                /* push ) */
                formula1[l] = formula2[l] = OP_CLOSE;
                l++;
            }

            formula1[l] = formula2[l] = OP_FIN; /* push . */

            n_ret += 2;
            ret = realloc(ret, (n_ret+1)*sizeof(int *));
            ret[n_ret-2] = formula1;
            ret[n_ret-1] = formula2;
            ret[n_ret] = NULL;
        }

        free_l((void **)perm);
    }

    return ret;
}


int **exhaust(int *formula, int **collection)
{
    int **m = r_mix(formula);
    int n_m = length_l((void **)m);
    if(n_m <= 0) {
        free_l((void **)m); // may be redundant
        return collection;
    }

    int i;
    for(i = 0; i < n_m; i++) collection = exhaust(m[i], collection);

    collection = push_uniq(collection, m);

    return collection;
}

int **genbf2(int n)
{
    int conj[n+3], i;
    conj[0] = OP_AND;
    for(i = 0; i < n; i++) conj[i+1] = i;
    conj[n+1] = OP_CLOSE;
    conj[n+2] = OP_FIN;

    return exhaust(conj, NULL);
}


int main(int argc, char *argv[])
{
    /* oh yeah baby this is the sexiest function name I've ever come up with */
    parallelize(&argc, &argv);

    /* set SIGINT handler for clean exits */
    signal(SIGINT, SIGINT_handler);

    /* I thing argc/argv checking is the most boring thing to program... */
    if(argc < 2) {
        pprintf("error: operation mode not specified\n"
                "mimir usage:    mim a <number of variables>\n"
                "                mim b <bf file> <start index> <stop index>\n"
                "                mim c <bf file>\n"
                "                mim v\n");
        return 1;
    }

    int ret, walltime;

    /* select mode of operation */
    switch(argv[1][0]) {
        /* mode A */
        case 'a':
        case 'A':
            if(argc < 3) {
                pprintf("error: invalid number of arguments (mode A)\n"
                        "mimir usage:    mim a <number of variables>\n");
                break;
            }

            int nvars = atoi(argv[2]);
            if(nvars < 1) {
                pprintf("error: number of variables must be strictly "
                        "positive\n");
                break;
            }

            ret = mode_a(nvars);
            deparallelize();
            return ret;

        case 'b':
        case 'B':
            if(argc < 5) {
                pprintf("error: invalid number of arguments (mode B)\n"
                        "mimir usage:    mim b <bf file> <start index> "
                        "<stop index> [wall time]\n");
                return 1;
            }

            int start = atoi(argv[3]);
            int stop = atoi(argv[4]);

            if(start < 0 || stop < 0) {
                printf("error: indices must be nonnegative\n");
                return 1;
            }
            else if(start > stop) {
                printf("error: start index greater than stop index\n");
                return 1;
            }

            walltime = WALLTIME_DEFAULT;
            if(argc == 6) {
                if((walltime = atoi(argv[5])) < 1) {
                    printf("error: wall time must be strictly positive\n");
                    return 1;
                }
            }

            ret = mode_b(argv[2], start, stop, walltime, 0, 0);
            deparallelize();
            return ret;

        case 'c':
        case 'C':
            if(argc < 2) {
                pprintf("error: invalid number of arguments (mode C)\n"
                        "mimir usage:    mim c <bf file> [wall time]\n");
                return 1;
            }

            walltime = WALLTIME_DEFAULT;
            if(argc == 4) {
                if((walltime = atoi(argv[3])) < 1) {
                    printf("error: wall time must be strictly positive\n");
                    return 1;
                }
            }

            ret = mode_c(argv[2], walltime);
            deparallelize();
            return ret;

        case 'v':
        case 'V':
            /* mode V */
            ret = mode_v();
            deparallelize();
            return ret;

        case 'x':
        case 'X':
            pprintf("mimir operation mode X\n");
            /* mode X - DEBUG MODE */
            int a[] = {OP_OR, OP_AND, 0, 1, OP_CLOSE, 2, OP_CLOSE, OP_FIN};
            int b[] = {OP_OR, OP_AND, 0, 1, OP_CLOSE, 2, OP_CLOSE, OP_FIN};
            pprintf("%d\n",max(a[0],b[0])); // bs to shut up -Wall

        default:
            pprintf("error: unrecognized operation mode %c\n", argv[1][0]);
    }

    deparallelize();
    return 1;


    /****************************************************/
        /* oh shit I didn't think this through, I need to store all the LHS or
         * RHS (at least) in memory to partition this task neatly */
        /* solution: store all lexicographically ordered ones in memory too */

        /* ...
         *
         *
         * anyway at this point all of them should be checked, and we should
         * also regularly do checkpointing */

        /* TODO: + read lexo bfs
         *       + check inferences and do checkpointing
         *       + exit strategy for when the program finished (new inference or not)
         *      !- sandbox mode X
         *       + handle SIGINT or whatever for when another program finishes
         *      !- fix the bug which breaks at 200 or whatever
         *      !- fix eval
         *       - fix the memory access problem?
         *       ~ clean up the code
         */
    return 0;
}
